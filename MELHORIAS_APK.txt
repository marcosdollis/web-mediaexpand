================================================================================
   MELHORIAS NECESSÁRIAS NO APK — MediaExpand TV App
   Gerado em: 24/02/2026
================================================================================


╔══════════════════════════════════════════════════════════════════════════════╗
║  1. CONTEÚDO CORPORATIVO VIA WEBVIEW (em vez de imagem/vídeo)              ║
╚══════════════════════════════════════════════════════════════════════════════╝

SITUAÇÃO ANTERIOR:
- O serializer tentava servir uma imagem PNG via arquivo_url
- ExoPlayer não sabe renderizar imagens, causava tela preta
- Tentamos gerar MP4, mas era pesado demais para o servidor

NOVA ABORDAGEM:
- O servidor agora retorna uma URL HTML completa no campo arquivo_url
  para itens com tipo == "corporativo"
- O app deve carregar essa URL num WebView em vez de ExoPlayer

FORMATO DA RESPOSTA DA API:
{
    "id": 900001,
    "titulo": "Cotações",
    "tipo": "corporativo",           ← IDENTIFICADOR CHAVE
    "subtipo": "COTACOES",           ← PREVISAO_TEMPO | COTACOES | NOTICIAS
    "duracao_segundos": 15,
    "ativo": true,
    "texto_tarja": null,
    "qrcode": null,
    "arquivo_url": "https://seu-dominio.railway.app/api/tv/corporativo/cotacoes/1/"
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                   É uma URL HTML, NÃO um arquivo de mídia!
}

IMPLEMENTAÇÃO NO ANDROID:
─────────────────────────

1. No layout XML, adicionar um WebView ao lado do PlayerView:

   <android.webkit.WebView
       android:id="@+id/webview_corporativo"
       android:layout_width="match_parent"
       android:layout_height="match_parent"
       android:visibility="gone" />

2. No código de reprodução da playlist, tratar o tipo "corporativo":

   // Kotlin
   when (currentItem.tipo) {
       "corporativo" -> {
           // Esconder player de vídeo
           playerView.visibility = View.GONE
           webView.visibility = View.VISIBLE

           // Configurar WebView
           webView.settings.javaScriptEnabled = true
           webView.settings.loadWithOverviewMode = true
           webView.settings.useWideViewPort = true
           webView.settings.domStorageEnabled = true

           // Forçar viewport 1920x1080 (resolução TV)
           webView.setInitialScale(100)

           // Carregar a URL
           webView.loadUrl(currentItem.arquivo_url)

           // Avançar para próximo item após a duração
           handler.postDelayed({
               webView.visibility = View.GONE
               playNext()
           }, currentItem.duracao_segundos * 1000L)
       }
       else -> {
           // Vídeo normal — usar ExoPlayer
           webView.visibility = View.GONE
           playerView.visibility = View.VISIBLE
           // ... código existente do ExoPlayer ...
       }
   }

3. Ao trocar de item, sempre cancelar o handler pendente:

   handler.removeCallbacksAndMessages(null)

4. Ao sair/destruir a Activity, limpar o WebView:

   webView.stopLoading()
   webView.destroy()

NOTAS:
- A página HTML já vem com relógio em tempo real (JavaScript)
- A resolução é fixa em 1920x1080 (ideal para TV)
- Fontes Inter (Google Fonts) e ícones Font Awesome são carregados via CDN
- O layout é 100% self-contained (não usa Django templates do admin)
- Se a rede cair, o WebView mostrará erro de carregamento (tratar com
  webView.setWebViewClient() mostrando tela de fallback)


╔══════════════════════════════════════════════════════════════════════════════╗
║  2. MÚLTIPLAS PLAYLISTS POR TV (vinculação com horário opcional)           ║
╚══════════════════════════════════════════════════════════════════════════════╝

SITUAÇÃO ANTERIOR:
- Cada dispositivo tinha UMA playlist fixa (playlist_atual)
- Agendamentos eram separados e confusos na UX

NOVA ABORDAGEM (Dispositivo → N Playlists):
- No painel web, na tela de detalhe do dispositivo, o franqueado vincula
  N playlists ao dispositivo com "Vincular Playlist"
- Cada vinculação tem horário OPCIONAL:
  · Se deixar horário vazio → a playlist roda 24/7 (fulltime)
  · Se definir horário → roda somente naquele período
- Prioridade resolve conflitos: playlist com horário específico tem
  prioridade sobre playlist 24/7
- O servidor resolve tudo — o app NÃO faz essa lógica

EXEMPLO DE USO (configuração no painel web):
  Playlist 1: "Interno"    → 08:00-10:00 (Seg-Sex) → horário comercial matutino
  Playlist 2: "Clientes"   → 10:00-18:00 (Seg-Sex) → horário comercial principal
  Playlist 3: "Geral"      → sem horário (24/7)    → roda quando nenhuma outra

LÓGICA DE PRIORIDADE NO SERVIDOR:
  1º Playlist com horário específico que bate com o momento atual
  2º Playlist 24/7 (fulltime) como fallback
  3º playlist_atual do dispositivo (compatibilidade)

IMPACTO NO APP:
- NENHUMA ALTERAÇÃO necessária no fluxo de autenticação/playlist
- O app continua fazendo POST /api/tv/auth/ e recebendo a playlist
- O servidor escolhe a playlist correta automaticamente
- A playlist pode mudar ao longo do dia

RECOMENDAÇÃO:
- O app deve re-autenticar periodicamente (a cada 5-10 minutos)
  para receber a playlist atualizada quando o horário muda
- Quando receber uma playlist_id diferente da atual, recarregar os itens
- Já faz isso? Se sim, nada precisa mudar

RESPOSTA ATUALIZADA DO endpoint /api/tv/check-schedule/:
{
    "should_display": true,              ← BASEADO NOS HORÁRIOS DE FUNCIONAMENTO
    "horarios_funcionamento": [          ← LISTA DE HORÁRIOS (pode ter N)
        {
            "nome": "Horário Comercial",
            "hora_inicio": "08:00",
            "hora_fim": "17:00",
            "dias_semana": [0,1,2,3,4],
            "ativo": true
        },
        {
            "nome": "Sábado",
            "hora_inicio": "09:00",
            "hora_fim": "13:00",
            "dias_semana": [5],
            "ativo": true
        }
    ],
    "playlist_id": 2,                    ← PODE MUDAR ao longo do dia
    "playlist_nome": "Clientes",
    "agendamentos": [
        {
            "nome": "Interno",
            "dias_semana": [0,1,2,3,4],
            "hora_inicio": "08:00",
            "hora_fim": "10:00",
            "playlist_id": 1,
            "playlist_nome": "Interno",
            "prioridade": 0
        },
        {
            "nome": "Clientes",
            "dias_semana": [0,1,2,3,4],
            "hora_inicio": "10:00",
            "hora_fim": "18:00",
            "playlist_id": 2,
            "playlist_nome": "Clientes",
            "prioridade": 0
        },
        {
            "nome": "Geral",
            "dias_semana": [],                ← VAZIO = todos os dias
            "hora_inicio": null,              ← NULL = 24/7
            "hora_fim": null,                 ← NULL = 24/7
            "playlist_id": 3,
            "playlist_nome": "Geral",
            "prioridade": 0
        }
    ]
}


╔══════════════════════════════════════════════════════════════════════════════╗
║  3. VÍDEOS COM PUBLICAÇÃO AGENDADA (via status do vídeo)                   ║
╚══════════════════════════════════════════════════════════════════════════════╝

SITUAÇÃO ANTERIOR:
- Existia um model separado "AgendamentoVideo" para agendar publicações
- UX era confusa — tela separada para gerenciar agendamentos de vídeo

NOVA ABORDAGEM (status no próprio vídeo):
- O vídeo agora tem 3 status possíveis:
  · APPROVED  → vídeo aprovado, exibido normalmente nas TVs
  · REJECTED  → vídeo rejeitado, nunca aparece nas TVs
  · SCHEDULED → vídeo agendado para publicação futura
- Campos novos no model Video:
  · data_publicacao (datetime, opcional) — quando o vídeo começa a aparecer
  · data_expiracao  (datetime, opcional) — quando o vídeo para de aparecer
- Lógica de visibilidade:
  · APPROVED → sempre visível nas TVs
  · SCHEDULED → só aparece se now >= data_publicacao E (data_expiracao é
    nula OU now <= data_expiracao)
  · REJECTED → nunca visível
- O vídeo pode estar vinculado a playlists normalmente, mas só aparece
  nas TVs quando a janela de data bate
- Tudo resolvido no servidor — o app não precisa mudar nada!

EXEMPLO DE USO (configuração no painel web):
  1. Franqueado faz upload do vídeo "Promoção Dia das Mães"
  2. Define status = "Agendado"
  3. Define data_publicacao = 01/05 00:00
  4. Define data_expiracao = 12/05 23:59  (opcional)
  5. Vincula o vídeo na playlist normalmente
  6. O vídeo só vai aparecer nas TVs entre 01/05 e 12/05
  7. Após 12/05, desaparece automaticamente

IMPACTO NO APP:
- NENHUMA ALTERAÇÃO necessária
- O serializer já filtra vídeos pela visibilidade (esta_visivel_nas_tvs)
- Vídeos SCHEDULED fora da janela de data simplesmente não aparecem
  na resposta da API
- O app recebe os mesmos campos de sempre


╔══════════════════════════════════════════════════════════════════════════════╗
║  4. HORÁRIO DE FUNCIONAMENTO DO DISPOSITIVO (ligar/desligar TV)             ║
╚══════════════════════════════════════════════════════════════════════════════╝

SITUAÇÃO ANTERIOR:
- O agendamento de ligar/desligar era controlado pelos agendamentos de playlist
- Confuso: misturava "qual playlist toca" com "TV liga/desliga"

NOVA ABORDAGEM (model HorarioFuncionamento — múltiplos horários por TV):
- O dispositivo agora tem N horários de funcionamento cadastrados
  (model separado: HorarioFuncionamento)
- Cada horário define:
  · nome — descritivo (ex: "Horário Comercial", "Sábado")
  · hora_inicio — hora que a TV liga (ex: 08:00)
  · hora_fim — hora que a TV desliga (ex: 17:00)
  · dias_semana — dias [0=Seg..6=Dom]. Vazio = todos
  · ativo — pode desativar sem deletar
- Se nenhum horário cadastrado → TV fica ligada 24h
- Se algum horário bate com o momento atual → should_display: true
- Se nenhum bate → should_display: false (tela preta)

EXEMPLO (2 horários no mesmo dispositivo):
  1. "Horário Comercial": 08:00-17:00, dias = [0,1,2,3,4] (Seg-Sex)
  2. "Sábado": 09:00-13:00, dias = [5]
  → TV liga 08h Seg-Sex e 09h Sáb
  → TV desliga 17h Seg-Sex e 13h Sáb
  → Domingo: TV desligada o dia todo
  → Sáb 14:00: should_display = false → tela preta
  → Seg 08:00: should_display = true → volta a tocar playlists

IMPACTO NO APP:
- NENHUMA ALTERAÇÃO necessária
- O app já trata should_display via onShouldDisplay():
  · should_display: true  → activateDisplay()
  · should_display: false → deactivateDisplay() (tela preta)
- O servidor agora retorna should_display baseado nos horários
  de funcionamento cadastrados no dispositivo

RESPOSTA DO endpoint /api/tv/check-schedule/ (campo atualizado):
{
    "should_display": false,
    "horarios_funcionamento": [
        {
            "nome": "Horário Comercial",
            "hora_inicio": "08:00",
            "hora_fim": "17:00",
            "dias_semana": [0,1,2,3,4],
            "ativo": true
        },
        {
            "nome": "Sábado",
            "hora_inicio": "09:00",
            "hora_fim": "13:00",
            "dias_semana": [5],
            "ativo": true
        }
    ],
    ...
}

FLUXO COMPLETO:
  1. App chama GET /api/tv/check-schedule/<UUID>/
  2. Servidor itera os HorarioFuncionamento ativos do dispositivo
  3. Se algum horário bate com agora → should_display: true
  4. Se nenhum bate → should_display: false
  5. App recebe false → deactivateDisplay() → tela preta
  6. Na próxima verificação (5-10 min), se entrou em algum horário:
     should_display: true → activateDisplay() → volta a tocar


╔══════════════════════════════════════════════════════════════════════════════╗
║  RESUMO DE ALTERAÇÕES NO APP                                               ║
╚══════════════════════════════════════════════════════════════════════════════╝

┌─────────────────────────────────────┬────────────────┬──────────────────────┐
│ Funcionalidade                      │ Alteração      │ Prioridade           │
├─────────────────────────────────────┼────────────────┼──────────────────────┤
│ Conteúdo corporativo via WebView    │ OBRIGATÓRIA    │ ALTA — sem isso,     │
│                                     │                │ conteúdo corporativo │
│                                     │                │ não funciona         │
├─────────────────────────────────────┼────────────────┼──────────────────────┤
│ Playlists vinculadas (N por TV)     │ NENHUMA*       │ — resolvido no       │
│ com horário opcional ou 24/7        │                │ servidor             │
├─────────────────────────────────────┼────────────────┼──────────────────────┤
│ Vídeos com publicação agendada      │ NENHUMA        │ — resolvido no       │
│ (status SCHEDULED + datas)          │                │ servidor             │
├─────────────────────────────────────┼────────────────┼──────────────────────┤
│ Horário de funcionamento da TV      │ NENHUMA**      │ — should_display já  │
│ (ligar/desligar por horário)        │                │ tratado pelo app     │
├─────────────────────────────────────┼────────────────┼──────────────────────┤
│ Re-autenticar periodicamente        │ RECOMENDADA    │ MÉDIA — para pegar   │
│ (a cada 5-10 min)                   │                │ troca de playlist    │
│                                     │                │ e ligar/desligar     │
├─────────────────────────────────────┼────────────────┼──────────────────────┤
│ Tratar erro de rede no WebView      │ RECOMENDADA    │ BAIXA — experiência  │
│                                     │                │ do usuário           │
└─────────────────────────────────────┴────────────────┴──────────────────────┘

*  O app já busca a playlist via POST /api/tv/auth/ — o servidor retorna
   a playlist correta para o horário. Se o app re-autenticar periodicamente,
   a troca de playlist por horário funciona automaticamente.
   Playlists vinculadas sem horário (24/7) servem como fallback.

** O app já trata should_display via onShouldDisplay(). O servidor agora
   retorna should_display: false quando fora de todos os horários de
   funcionamento do dispositivo. O app faz deactivateDisplay() (tela preta)
   e volta a activateDisplay() quando should_display volta a ser true.


╔══════════════════════════════════════════════════════════════════════════════╗
║  ENDPOINTS DA API (referência)                                             ║
╚══════════════════════════════════════════════════════════════════════════════╝

POST /api/tv/auth/
  → Autenticação + retorna playlist (já seleciona por horário)
  Body: { "identificador_unico": "UUID", "versao_app": "1.0.0" }

GET  /api/tv/check-schedule/<UUID>/
  → Verifica se deve exibir + retorna agendamentos com playlists

GET  /api/tv/corporativo/<tipo>/<playlist_id>/
  → Página HTML para WebView (corporativo)
  Tipos: previsao_tempo, cotacoes, noticias
  Exemplo: /api/tv/corporativo/cotacoes/1/

POST /api/tv/log-exibicao/
  → Registra log de exibição (sem alteração)

================================================================================
