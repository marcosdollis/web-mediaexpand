================================================================================
   MELHORIAS NECESSÁRIAS NO APK — MediaExpand TV App
   Gerado em: 24/02/2026
================================================================================


╔══════════════════════════════════════════════════════════════════════════════╗
║  1. CONTEÚDO CORPORATIVO VIA WEBVIEW (em vez de imagem/vídeo)              ║
╚══════════════════════════════════════════════════════════════════════════════╝

SITUAÇÃO ANTERIOR:
- O serializer tentava servir uma imagem PNG via arquivo_url
- ExoPlayer não sabe renderizar imagens, causava tela preta
- Tentamos gerar MP4, mas era pesado demais para o servidor

NOVA ABORDAGEM:
- O servidor agora retorna uma URL HTML completa no campo arquivo_url
  para itens com tipo == "corporativo"
- O app deve carregar essa URL num WebView em vez de ExoPlayer

FORMATO DA RESPOSTA DA API:
{
    "id": 900001,
    "titulo": "Cotações",
    "tipo": "corporativo",           ← IDENTIFICADOR CHAVE
    "subtipo": "COTACOES",           ← PREVISAO_TEMPO | COTACOES | NOTICIAS
    "duracao_segundos": 15,
    "ativo": true,
    "texto_tarja": null,
    "qrcode": null,
    "arquivo_url": "https://seu-dominio.railway.app/api/tv/corporativo/cotacoes/1/"
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                   É uma URL HTML, NÃO um arquivo de mídia!
}

IMPLEMENTAÇÃO NO ANDROID:
─────────────────────────

1. No layout XML, adicionar um WebView ao lado do PlayerView:

   <android.webkit.WebView
       android:id="@+id/webview_corporativo"
       android:layout_width="match_parent"
       android:layout_height="match_parent"
       android:visibility="gone" />

2. No código de reprodução da playlist, tratar o tipo "corporativo":

   // Kotlin
   when (currentItem.tipo) {
       "corporativo" -> {
           // Esconder player de vídeo
           playerView.visibility = View.GONE
           webView.visibility = View.VISIBLE

           // Configurar WebView
           webView.settings.javaScriptEnabled = true
           webView.settings.loadWithOverviewMode = true
           webView.settings.useWideViewPort = true
           webView.settings.domStorageEnabled = true

           // Forçar viewport 1920x1080 (resolução TV)
           webView.setInitialScale(100)

           // Carregar a URL
           webView.loadUrl(currentItem.arquivo_url)

           // Avançar para próximo item após a duração
           handler.postDelayed({
               webView.visibility = View.GONE
               playNext()
           }, currentItem.duracao_segundos * 1000L)
       }
       else -> {
           // Vídeo normal — usar ExoPlayer
           webView.visibility = View.GONE
           playerView.visibility = View.VISIBLE
           // ... código existente do ExoPlayer ...
       }
   }

3. Ao trocar de item, sempre cancelar o handler pendente:

   handler.removeCallbacksAndMessages(null)

4. Ao sair/destruir a Activity, limpar o WebView:

   webView.stopLoading()
   webView.destroy()

NOTAS:
- A página HTML já vem com relógio em tempo real (JavaScript)
- A resolução é fixa em 1920x1080 (ideal para TV)
- Fontes Inter (Google Fonts) e ícones Font Awesome são carregados via CDN
- O layout é 100% self-contained (não usa Django templates do admin)
- Se a rede cair, o WebView mostrará erro de carregamento (tratar com
  webView.setWebViewClient() mostrando tela de fallback)


╔══════════════════════════════════════════════════════════════════════════════╗
║  2. MÚLTIPLAS PLAYLISTS POR TV (vinculação com horário opcional)           ║
╚══════════════════════════════════════════════════════════════════════════════╝

SITUAÇÃO ANTERIOR:
- Cada dispositivo tinha UMA playlist fixa (playlist_atual)
- Agendamentos eram separados e confusos na UX

NOVA ABORDAGEM (Dispositivo → N Playlists):
- No painel web, na tela de detalhe do dispositivo, o franqueado vincula
  N playlists ao dispositivo com "Vincular Playlist"
- Cada vinculação tem horário OPCIONAL:
  · Se deixar horário vazio → a playlist roda 24/7 (fulltime)
  · Se definir horário → roda somente naquele período
- Prioridade resolve conflitos: playlist com horário específico tem
  prioridade sobre playlist 24/7
- O servidor resolve tudo — o app NÃO faz essa lógica

EXEMPLO DE USO (configuração no painel web):
  Playlist 1: "Interno"    → 08:00-10:00 (Seg-Sex) → horário comercial matutino
  Playlist 2: "Clientes"   → 10:00-18:00 (Seg-Sex) → horário comercial principal
  Playlist 3: "Geral"      → sem horário (24/7)    → roda quando nenhuma outra

LÓGICA DE PRIORIDADE NO SERVIDOR:
  1º Playlist com horário específico que bate com o momento atual
  2º Playlist 24/7 (fulltime) como fallback
  3º playlist_atual do dispositivo (compatibilidade)

IMPACTO NO APP:
- NENHUMA ALTERAÇÃO necessária no fluxo de autenticação/playlist
- O app continua fazendo POST /api/tv/auth/ e recebendo a playlist
- O servidor escolhe a playlist correta automaticamente
- A playlist pode mudar ao longo do dia

RECOMENDAÇÃO:
- O app deve re-autenticar periodicamente (a cada 5-10 minutos)
  para receber a playlist atualizada quando o horário muda
- Quando receber uma playlist_id diferente da atual, recarregar os itens
- Já faz isso? Se sim, nada precisa mudar

RESPOSTA ATUALIZADA DO endpoint /api/tv/check-schedule/:
{
    "should_display": true,
    "playlist_id": 2,                    ← PODE MUDAR ao longo do dia
    "playlist_nome": "Clientes",
    "agendamentos": [
        {
            "nome": "Interno",
            "dias_semana": [0,1,2,3,4],
            "hora_inicio": "08:00",
            "hora_fim": "10:00",
            "playlist_id": 1,
            "playlist_nome": "Interno",
            "prioridade": 0
        },
        {
            "nome": "Clientes",
            "dias_semana": [0,1,2,3,4],
            "hora_inicio": "10:00",
            "hora_fim": "18:00",
            "playlist_id": 2,
            "playlist_nome": "Clientes",
            "prioridade": 0
        },
        {
            "nome": "Geral",
            "dias_semana": [],                ← VAZIO = todos os dias
            "hora_inicio": null,              ← NULL = 24/7
            "hora_fim": null,                 ← NULL = 24/7
            "playlist_id": 3,
            "playlist_nome": "Geral",
            "prioridade": 0
        }
    ]
}


╔══════════════════════════════════════════════════════════════════════════════╗
║  3. VÍDEOS COM PUBLICAÇÃO AGENDADA (via status do vídeo)                   ║
╚══════════════════════════════════════════════════════════════════════════════╝

SITUAÇÃO ANTERIOR:
- Existia um model separado "AgendamentoVideo" para agendar publicações
- UX era confusa — tela separada para gerenciar agendamentos de vídeo

NOVA ABORDAGEM (status no próprio vídeo):
- O vídeo agora tem 3 status possíveis:
  · APPROVED  → vídeo aprovado, exibido normalmente nas TVs
  · REJECTED  → vídeo rejeitado, nunca aparece nas TVs
  · SCHEDULED → vídeo agendado para publicação futura
- Campos novos no model Video:
  · data_publicacao (datetime, opcional) — quando o vídeo começa a aparecer
  · data_expiracao  (datetime, opcional) — quando o vídeo para de aparecer
- Lógica de visibilidade:
  · APPROVED → sempre visível nas TVs
  · SCHEDULED → só aparece se now >= data_publicacao E (data_expiracao é
    nula OU now <= data_expiracao)
  · REJECTED → nunca visível
- O vídeo pode estar vinculado a playlists normalmente, mas só aparece
  nas TVs quando a janela de data bate
- Tudo resolvido no servidor — o app não precisa mudar nada!

EXEMPLO DE USO (configuração no painel web):
  1. Franqueado faz upload do vídeo "Promoção Dia das Mães"
  2. Define status = "Agendado"
  3. Define data_publicacao = 01/05 00:00
  4. Define data_expiracao = 12/05 23:59  (opcional)
  5. Vincula o vídeo na playlist normalmente
  6. O vídeo só vai aparecer nas TVs entre 01/05 e 12/05
  7. Após 12/05, desaparece automaticamente

IMPACTO NO APP:
- NENHUMA ALTERAÇÃO necessária
- O serializer já filtra vídeos pela visibilidade (esta_visivel_nas_tvs)
- Vídeos SCHEDULED fora da janela de data simplesmente não aparecem
  na resposta da API
- O app recebe os mesmos campos de sempre


╔══════════════════════════════════════════════════════════════════════════════╗
║  RESUMO DE ALTERAÇÕES NO APP                                               ║
╚══════════════════════════════════════════════════════════════════════════════╝

┌─────────────────────────────────────┬────────────────┬──────────────────────┐
│ Funcionalidade                      │ Alteração      │ Prioridade           │
├─────────────────────────────────────┼────────────────┼──────────────────────┤
│ Conteúdo corporativo via WebView    │ OBRIGATÓRIA    │ ALTA — sem isso,     │
│                                     │                │ conteúdo corporativo │
│                                     │                │ não funciona         │
├─────────────────────────────────────┼────────────────┼──────────────────────┤
│ Playlists vinculadas (N por TV)     │ NENHUMA*       │ — resolvido no       │
│ com horário opcional ou 24/7        │                │ servidor             │
├─────────────────────────────────────┼────────────────┼──────────────────────┤
│ Vídeos com publicação agendada      │ NENHUMA        │ — resolvido no       │
│ (status SCHEDULED + datas)          │                │ servidor             │
├─────────────────────────────────────┼────────────────┼──────────────────────┤
│ Re-autenticar periodicamente        │ RECOMENDADA    │ MÉDIA — para pegar   │
│ (a cada 5-10 min)                   │                │ troca de playlist    │
│                                     │                │ por horário          │
├─────────────────────────────────────┼────────────────┼──────────────────────┤
│ Tratar erro de rede no WebView      │ RECOMENDADA    │ BAIXA — experiência  │
│                                     │                │ do usuário           │
└─────────────────────────────────────┴────────────────┴──────────────────────┘

* O app já busca a playlist via POST /api/tv/auth/ — o servidor retorna
  a playlist correta para o horário. Se o app re-autenticar periodicamente,
  a troca de playlist por horário funciona automaticamente.
  Playlists vinculadas sem horário (24/7) servem como fallback.


╔══════════════════════════════════════════════════════════════════════════════╗
║  ENDPOINTS DA API (referência)                                             ║
╚══════════════════════════════════════════════════════════════════════════════╝

POST /api/tv/auth/
  → Autenticação + retorna playlist (já seleciona por horário)
  Body: { "identificador_unico": "UUID", "versao_app": "1.0.0" }

GET  /api/tv/check-schedule/<UUID>/
  → Verifica se deve exibir + retorna agendamentos com playlists

GET  /api/tv/corporativo/<tipo>/<playlist_id>/
  → Página HTML para WebView (corporativo)
  Tipos: previsao_tempo, cotacoes, noticias
  Exemplo: /api/tv/corporativo/cotacoes/1/

POST /api/tv/log-exibicao/
  → Registra log de exibição (sem alteração)

================================================================================
